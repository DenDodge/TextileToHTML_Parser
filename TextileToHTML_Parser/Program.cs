using System;
using System.Collections.Generic;
using TextileToHTML;

namespace TextileToHTMLToHTML_Parser
{
    internal class Program
    {
        static void Main(string[] args)
        {
            Dictionary<string, Guid> attachemntsIds = new Dictionary<string, Guid>()
            {
                { "1.png", new Guid("49ba1622-55d9-48c5-a4d5-9a85801fd62a") },
                { "2.png", new Guid("8166b72b-3a3b-4198-9cb9-657da5d9f8ee") },
                { "07.11.12.png", new Guid("8b22ba42-6404-4130-bd1b-ff2fb037f893") }
            };

            string filesDirectory = $"D:\\WORK_SYNTELLECT\\OtherFiles\\Migration\\1072";

            //string testString = "Что нужно сделать.\r\n\r\nh1. В справочнике типовых задач\r\n\r\n# В форме типовой задачи сделать два флажка (и поля в базе): Для КАСКО, Для ОСАГО. По умолчанию ОБА установлены.\r\n# Сверху формы сделать выпадающий список, позволяющий фильтровать текущий список задач:  Задачи КАСКО, Задачи ОСАГО, Задачи КАСКО\\ОСАГО, Все. Получается 4 варианта фильтра. По умолчанию выбрано ВСЕ.\r\n\r\nh1. В диалоге передачи КД.\r\n\r\n# Диалог расширить так, чтобы поле для передачи КД расширилось в два раза.\r\n# Выпадающий список ТЗ увеличить в высоту тоже в два раза.\r\n# Если текущая КД - КАСКО, то в списке только задачи где стоит флажок КАСКО, Если текущая КД - ОСАГО - то в списке типовых задач только задачи ОСАГО.\r\n";
            //string testString = "Добрый день! Вопрос срочный!\r\nДля реализации процесса согласования кредитных заявок, при заполнения карточки \"Кредитная заявка\" требуется следующее:\r\nполучение искомого списка клиентов из CRM в DocsVision.\r\n \r\nПредлагается следующий алгоритм:\r\n1. Инициатор создает карточку регистрации \"Кредитная заявка\".\r\n2. В поле \"Наименование клиента\" указывает предварительную запись(имя) клиента и нажимает кнопку \"Найти\". Кнопка \"Очистить\" только для чтения (не активна).\r\n3. После активизации кнопки \"Найти\" происходит обращение к базе данных CRM и по установленному запросу выполняется поиск возможных значений.\r\n4. Найденные записи клиентов отображаются в виде выпадающего списка (доп.окно) с возможностью выбора искомого значения. При нажатии \"ОК\"  выбранная запись отображается в поле \"Наименование клиента\", а так же заполняется поле \"Группа компаний\" (информация берется из данных по клиенту) с переводом полей в режим чтения. Кнопка \"Найти\" переводится в не активна, а кнопка \"Очистить\" доступна для использования.\r\n5. Если поле \"Наименование клиента\" требуется изменить , то при нажатии кнопки \"Очистить\" поля \"Наименование клиента\" и \"Группа компаний\" очищаются, с переводом кнопки \"Найти\" в активное состояние.\r\nКнопки \"Найти\", \"Очистить\", \"Собрать номер\" должны срабатывать только при состоянии документа \"Проект\" или \"Отозван\", т.е. когда документ запущен на согласование кнопки для использования недоступны.\r\n\r\nВ приложении скан карточки. \r\n\r\n";
            string testString = "Добрый вечер\r\n\r\nОбъясню ситуацию, которую мы наблюдаем по всему описанному в таске.\r\n\r\nСо стороны TessaClient метод подписания выглядит так:\r\n\r\n<pre><code class=\"java\">\r\npublic override async ValueTask<byte[]> GenerateSignatureAsync(\r\n    byte[] certificate,\r\n    ISignatureFile file,\r\n    string hashAlgo,\r\n    CancellationToken cancellationToken = default)\r\n{\r\n    ITempFile tempFile = null;\r\n    \r\n    try\r\n    {\r\n        string filePath = file.TryGetLocalPath();\r\n        if (string.IsNullOrEmpty(filePath))\r\n        {\r\n            byte[] bytes = await file.GetBytesAsync(cancellationToken).ConfigureAwait(false);\r\n            \r\n            tempFile = TempFile.Acquire(\"eds-sign.bin\");\r\n            await File.WriteAllBytesAsync(tempFile.Path, bytes, cancellationToken).ConfigureAwait(false);\r\n\r\n            filePath = tempFile.Path;\r\n        }\r\n\r\n        byte[] cmsData = await this.service.GenerateSignatureAsync(filePath, hashAlgo, certificate, cancellationToken).ConfigureAwait(false);\r\n        return cmsData;\r\n    }\r\n    finally\r\n    {\r\n        tempFile?.Dispose();\r\n    }\r\n}\r\n</code></pre>\r\n\r\nТ.е. исходный подписываемый файл копируется вызовом @File.WriteAllBytesAsync@ в отдельный временный файл @\"eds-sign.bin\"@, который расположен в подпапке со случайным именем @\"ltn4dnhx.5eo\"@, причём имя генерируется при вызове @TempFile.Acquire@ - два вызова метода подписания не могут пересечься для одного и того же файла.\r\n\r\nВнутри процесса @TessaHost@ есть метод @GenerateSignatureAsync@ со следующим содержимым:\r\n\r\n<pre><code class=\"java\">\r\npublic ValueTask<byte[]> GenerateSignatureAsync(\r\n    string filePath,\r\n    string hashAlgorithm,\r\n    byte[] certificate,\r\n    CancellationToken cancellationToken = default)\r\n{\r\n    this.CheckFilePath(filePath, nameof(filePath));\r\n\r\n    if (certificate is null)\r\n    {\r\n        throw new ArgumentNullException(nameof(certificate));\r\n    }\r\n\r\n    logger.Trace(\"{0}: Called {1} for file: {2}\", this.GetType().Name, nameof(this.GenerateSignatureAsync), filePath);\r\n\r\n    byte[] file = File.ReadAllBytes(filePath);\r\n\r\n    logger.Trace(\"{0}: File is loaded from disk: {1}\", this.GetType().Name, filePath);\r\n\r\n    byte[] encodedSignature = this.GenerateSignatureCore(certificate, file, hashAlgorithm);\r\n\r\n    logger.Trace(\"{0}: Signature is encoded for file: {1}\", this.GetType().Name, filePath);\r\n\r\n    return new ValueTask<byte[]>(encodedSignature);\r\n}\r\n</code></pre>\r\n\r\nЗдесь @filePath@ - это путь до того временного файла @eds-sign.bin@. Его чтение выполняется как @File.ReadAllBytes@, поэтому, опять же, не может быть каких-то забытых @stream.Dispose@, которые бы удерживались в процессе @TessaHost@. Сам метод подписания ЭП @GenerateSignatureCore@ получает на вход массив байт, а не файл, и файл к этому моменту закрыт.\r\n\r\nПадает вызываемый в первой строке метод @CheckFilePath@:\r\n\r\n<pre><code class=\"java\">\r\nprivate void CheckFilePath(string filePath, string paramName)\r\n{\r\n    if (filePath is null)\r\n    {\r\n        throw new ArgumentNullException(paramName);\r\n    }\r\n\r\n    if (filePath.Length == 0)\r\n    {\r\n        throw new ArgumentException(\"File path can't be empty string.\", paramName);\r\n    }\r\n\r\n    if (!File.Exists(filePath))\r\n    {\r\n        throw new InvalidOperationException($\"{this.GetType().Name}: Can't find file by path: {filePath}\");\r\n    }\r\n}\r\n</code></pre>\r\n\r\nКак видим в MSDN, ситуация с методом @File.Exists@ такая:\r\n\r\n> The Exists method returns false if any error occurs while trying to determine if the specified file exists. This can occur in situations that raise exceptions such as passing a file name with invalid characters or too many characters, a failing or missing disk, or if the *caller does not have permission to read the file*.\r\n\r\nhttps://docs.microsoft.com/en-us/dotnet/api/system.io.file.exists?view=net-5.0\r\n\r\nТаким образом, если в процессе TessaHost действительно нет прав на чтение файла, как и выводится в предварительной ошибке, то да, TessaHost ругается именно исключением с указанным текстом.\r\n\r\n> Судя по логам, данной ошибке обычно предшествует предупреждение вида: The process cannot access the file 'C:\\Users\\yavorskiy\\AppData\\Local\\Temp\\Tessa\\Files\\2xwyn2mg.n3r\\eds-sign.bin' because it is being used by another process.\r\n\r\nКак раз наоборот, это предупреждение идёт следом за указанным, когда TessaClient пытается удалить временный файл в finally-блоке вызовом @tempFile?.Dispose()@\r\n\r\nЭто видно в полном стек-трейсе этой ошибки:\r\n\r\n<pre>\r\n2021-03-29 17:16:36.1593|WARN|Tessa.Platform.IO.FileHelper|Failed to delete file \"C:\\Users\\yavorskiy\\AppData\\Local\\Temp\\Tessa\\Files\\5vij03ig.edh\\eds-sign.bin\". Call stack:\r\n   at Tessa.Platform.IO.FileHelper.ReleaseFilePath(String filePath, Boolean keepFolder, Exception& exception)\r\n   at Tessa.Platform.IO.TempFile.TempFileInstance.Dispose()\r\n   at Tessa.Extensions.Default.Client.EDS.ServiceEDSManagerForCAdES.GenerateSignatureAsync(Byte[] certificate, ISignatureFile file, String hashAlgo, CancellationToken cancellationToken) in D:\\Projects\\Tessa\\PPPUpdate\\pppudp\\Extensions\\Tessa.Extensions.Default.Client\\EDS\\ServiceEDSManagerForCAdES.cs:line 115\r\n   at Tessa.Host.EDS.EdsServiceHost.GenerateSignatureAsync(String filePath, String hashAlgorithm, Byte[] certificate, CancellationToken cancellationToken)\r\n   at Tessa.Host.EDS.EdsServiceClient.GenerateSignatureAsync(String filePath, String hashAlgorithm, Byte[] certificate, CancellationToken cancellationToken)\r\n   at Tessa.Platform.Pipes.PipeClientConnection.SendCoreAsync(IPipeRequest request, CancellationToken cancellationToken)\r\n   at Tessa.Platform.Pipes.PipeSerializer.ReadStringAsync(PipeStream pipe, CancellationToken cancellationToken)\r\n   at Tessa.Platform.Pipes.PipeSerializer.ReadBytesCoreAsync(PipeStream pipe, CancellationToken cancellationToken)\r\n   at System.Threading.ThreadPoolWorkQueue.Dispatch()\r\n-------------------\r\nSystem.IO.IOException: The process cannot access the file 'C:\\Users\\yavorskiy\\AppData\\Local\\Temp\\Tessa\\Files\\5vij03ig.edh\\eds-sign.bin' because it is being used by another process.\r\n   at System.IO.FileSystem.DeleteFile(String fullPath)\r\n   at Tessa.Platform.IO.FileHelper.ReleaseFilePath(String filePath, Boolean keepFolder, Exception& exception)\r\n</pre>\r\n\r\nВозникает вопрос, кем удерживается файл, когда TessaHost пытается к нему обратиться, и из-за чего перезапуск TessaHost позитивно складывается на ошибке, если при каждом подписании файл новый.\r\n\r\nМожно спекулировать, что дело в таймингах, когда файл, несмотря на завершение асинхронного @File.WriteAllBytesAsync@ в TessaClient, всё ещё открыт сколько-то миллисекунд. И если TessaHost уже запущен, то вызов выполняется слишком быстро, и TessaHost сразу же падает на @File.Exists@. Тогда как если TessaHost не запущен, то он секунду запускается, и файл успевает \"отпустить\".";
            Parser parser = new Parser(testString, filesDirectory, attachemntsIds, true);
            var result = parser.GetParsedString();
        }
    }
}
